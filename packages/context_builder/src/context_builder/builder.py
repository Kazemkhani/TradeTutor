"""Context Builder using Stanford DSPy.

This module builds ContextInstance objects for voice calls.
It runs BEFORE the call starts, not during the real-time loop.

DSPy is used for:
- Generating agent instructions based on goal
- Creating personalized opening lines
- Building qualification questions
- Generating objection handlers (assertive for close_sale)
- Determining email configuration (booking/payment links)

The output is a ContextInstance JSON that the voice agent
receives via the --context flag.
"""

import logging

# Placeholder for DSPy imports - will be added when implementing
# import dspy
from shared.schemas import (
    CallGoal,
    CallRequest,
    ContextInstance,
    Lead,
)
from shared.scraper import (
    WebsiteScraper,
    summarize_website_content,
)

logger = logging.getLogger("context-builder")


class ContextBuilder:
    """Builds ContextInstance for voice calls using DSPy.

    This class encapsulates the DSPy-based context building logic.
    It takes a CallRequest (form submission) and produces a fully-populated
    ContextInstance ready for the voice agent.

    Usage:
        builder = ContextBuilder()
        context = builder.build(call_request)
        context.model_dump_json()  # Save to file for agent
    """

    def __init__(
        self, llm_model: str | None = None, firecrawl_api_key: str | None = None
    ):
        """Initialize the context builder.

        Args:
            llm_model: Optional LLM model for DSPy. If not provided,
                      will use DSPy's default configuration.
            firecrawl_api_key: Optional Firecrawl API key for website scraping.
        """
        self.llm_model = llm_model
        self.scraper = WebsiteScraper(api_key=firecrawl_api_key)
        # TODO: Initialize DSPy LLM here
        # dspy.configure(lm=dspy.LM(model=llm_model))

    def build(self, request: CallRequest, lead: Lead) -> ContextInstance:
        """Build a ContextInstance from a CallRequest for a specific lead.

        Args:
            request: The form submission to build context for.
            lead: The specific lead this context is for (each lead is a distinct person).

        Returns:
            A fully-populated ContextInstance ready for the voice agent.
        """
        # Scrape website if URL provided to enrich context
        enriched_request = self._enrich_with_website(request)

        # Generate agent instructions based on goal and product
        agent_instructions = self._generate_agent_instructions(enriched_request)

        # Generate personalized opening line (per-lead name and company)
        opening_line = self._generate_opening_line(enriched_request, lead)

        # Generate qualification questions based on goal
        qualification_questions = self._generate_qualification_questions(
            enriched_request
        )

        # Generate objection handlers (more assertive for close_sale)
        objection_handlers = self._generate_objection_handlers(enriched_request)

        # Generate closing script
        closing_script = self._generate_closing_script(enriched_request)

        # Determine email configuration for lead
        should_email_lead = request.goal in (CallGoal.BOOK_MEETING, CallGoal.CLOSE_SALE)
        lead_email_template = ""
        if request.goal == CallGoal.BOOK_MEETING:
            lead_email_template = "booking"
        elif request.goal == CallGoal.CLOSE_SALE:
            lead_email_template = "payment"

        return ContextInstance(
            # From form submission
            owner_email=request.owner_email,
            phone=lead.phone,
            name=lead.name,
            lead_company=lead.company,
            lead_title=lead.title,
            lead_email_preknown=lead.email,
            product=request.product,
            goal=request.goal,
            booking_link=request.booking_link,
            payment_link=request.payment_link,
            pricing_summary=request.pricing_summary,
            urgency_hook=request.urgency_hook,
            goal_criteria=request.goal_criteria,
            # Generated by DSPy
            agent_instructions=agent_instructions,
            opening_line=opening_line,
            qualification_questions=qualification_questions,
            objection_handlers=objection_handlers,
            closing_script=closing_script,
            # Email config
            should_email_lead=should_email_lead,
            lead_email_template=lead_email_template,
        )

    def _enrich_with_website(self, request: CallRequest) -> CallRequest:
        """Scrape website and enrich the request context.

        Args:
            request: The original call request.

        Returns:
            A new CallRequest with enriched context from website scraping.
        """
        if not request.website_url:
            return request

        logger.info(f"Scraping website: {request.website_url}")
        scraped = self.scraper.scrape(request.website_url)

        if not scraped.success:
            logger.warning(f"Failed to scrape website: {scraped.error}")
            return request

        # Summarize scraped content
        website_summary = summarize_website_content(scraped, max_chars=1500)

        if not website_summary:
            return request

        # Combine existing context with website content
        enriched_context = request.context or ""
        if enriched_context:
            enriched_context += "\n\n--- SCRAPED FROM WEBSITE ---\n\n"
        enriched_context += website_summary

        logger.info(f"Enriched context with {len(website_summary)} chars from website")

        # Create new request with enriched context
        return CallRequest(
            owner_email=request.owner_email,
            leads=request.leads,
            product=request.product,
            goal=request.goal,
            context=enriched_context,
            consent=request.consent,
            website_url=request.website_url,
            booking_link=request.booking_link,
            payment_link=request.payment_link,
            pricing_summary=request.pricing_summary,
            urgency_hook=request.urgency_hook,
            goal_criteria=request.goal_criteria,
        )

    def _generate_agent_instructions(self, request: CallRequest) -> str:
        """Generate agent instructions using DSPy.

        TODO: Implement with DSPy module for dynamic generation.
        """
        # Goal-specific instructions
        if request.goal == CallGoal.CLOSE_SALE:
            # Assertive, value-driven sales closer
            instructions = f"""You are a confident, value-driven sales closer for {request.product}.

OBJECTIVE: Get a verbal commitment to purchase and collect their email.

OPENING: Hook immediately with the core value proposition.

DISCOVERY: Ask ONE quick question to understand their pain point.

PITCH: Connect their pain to your solution. Be specific about:
- Key benefit: What {request.product} does for them
"""
            if request.pricing_summary:
                instructions += f"- Pricing: {request.pricing_summary}\n"

            instructions += """
OBJECTION HANDLING:
- "Too expensive" → Focus on ROI and value justification
- "Need to think" → Create urgency or schedule follow-up
- "Not the right time" → Highlight opportunity cost of waiting
- "Need to check with..." → Offer to include them or schedule follow-up

CLOSE: After addressing objections, ask directly:
"Should I send you the link to get started today?"

IF YES: Collect their email to send the payment link.
IF NO: Thank them professionally and end the call.
"""
            if request.urgency_hook:
                instructions += f"\nURGENCY: {request.urgency_hook}"

            instructions += (
                "\n\nTONE: Confident but not pushy. You believe in the product."
            )

        elif request.goal == CallGoal.BOOK_MEETING:
            instructions = f"""You are a professional representative for {request.product}.

OBJECTIVE: Schedule a demo or meeting with the prospect.

Your approach:
1. Briefly introduce yourself and {request.product}
2. Ask about their current situation and challenges
3. Position how {request.product} can help
4. Propose scheduling a meeting/demo
5. If they agree, collect their email to send the booking link

Be helpful and consultative. Focus on understanding their needs."""
            if request.booking_link:
                instructions += (
                    "\n\nIf they're interested, offer to email them a booking link."
                )

        elif request.goal == CallGoal.COLLECT_INFO:
            instructions = f"""You are a professional representative for {request.product}.

OBJECTIVE: Gather key information from the prospect.

Your approach:
1. Briefly introduce yourself and the purpose of the call
2. Ask the qualification questions provided
3. Listen carefully and take note of their responses
4. Thank them for their time

Be respectful of their time. Focus on collecting accurate information."""
            if request.goal_criteria:
                instructions += f"\n\nInformation to collect: {request.goal_criteria}"

        else:  # QUALIFY_INTEREST
            instructions = f"""You are a professional representative for {request.product}.

OBJECTIVE: Understand their interest level and qualify them as a potential customer.

Your approach:
1. Briefly introduce yourself and {request.product}
2. Ask about their current situation and needs
3. Determine if they're a good fit based on their responses
4. Note their level of interest and any concerns

Be professional and consultative. Focus on understanding their needs."""
            if request.goal_criteria:
                instructions += f"\n\nQualification criteria: {request.goal_criteria}"

        # Add product context if provided
        if request.context:
            instructions += f"\n\nPRODUCT CONTEXT:\n{request.context}"

        return instructions.strip()

    def _generate_opening_line(self, request: CallRequest, lead: Lead) -> str:
        """Generate personalized opening line for a specific lead.

        Uses the lead's name and company for personalization.

        TODO: Implement with DSPy module.
        """
        greeting = f"Hi, may I speak with {lead.name}?" if lead.name else "Hi there!"

        company_mention = ""
        if lead.company:
            company_mention = f" I understand you're at {lead.company}."

        if request.goal == CallGoal.CLOSE_SALE:
            # More direct, value-focused opening
            return f"{greeting}{company_mention} I'm calling about {request.product} - we help businesses like yours achieve better results. Do you have 2 minutes?"
        else:
            return f"{greeting}{company_mention} I'm calling about {request.product}."

    def _generate_qualification_questions(self, request: CallRequest) -> list[str]:
        """Generate qualification questions based on goal.

        TODO: Implement with DSPy module.
        """
        if request.goal == CallGoal.CLOSE_SALE:
            # Minimal discovery for close_sale - focus on closing
            questions = [
                "What's your biggest challenge in this area right now?",
            ]
        elif request.goal == CallGoal.BOOK_MEETING:
            questions = [
                "What challenges are you currently facing in this area?",
                "What's your timeline for making a decision?",
                "What time works best for a quick demo?",
            ]
        elif request.goal == CallGoal.COLLECT_INFO:
            # Use goal_criteria if provided, otherwise generic
            if request.goal_criteria:
                questions = [f"Could you tell me about {request.goal_criteria}?"]
            else:
                questions = [
                    "Can you tell me about your current situation?",
                    "What's most important to you in a solution like this?",
                ]
        else:  # QUALIFY_INTEREST
            questions = [
                "What challenges are you currently facing in this area?",
                "What's your timeline for making a decision?",
                "Who else would be involved in this decision?",
                "What's your budget range for this type of solution?",
            ]

        return questions

    def _generate_objection_handlers(self, request: CallRequest) -> dict[str, str]:
        """Generate objection handlers.

        TODO: Implement with DSPy module.
        """
        if request.goal == CallGoal.CLOSE_SALE:
            # More assertive handlers for close_sale
            handlers = {
                "too_expensive": f"I hear you. But consider this - {request.product} typically pays for itself within the first month through increased efficiency. What would it mean for your business to see those results?",
                "need_to_think": "I completely understand. What specific concerns do you have that I can address right now? Often the best time to start is today.",
                "not_interested": "I appreciate your honesty. May I ask - is it the timing, or is there something specific about the solution that doesn't fit your needs?",
                "bad_timing": "I get it. Though I should mention - the current offer won't last forever. Would it make sense to lock in the rate now and start when you're ready?",
                "need_approval": "That makes sense. Would it help if I put together a quick summary you could share with them? Or I could join a call to answer their questions directly.",
            }
            if request.urgency_hook:
                handlers["hesitation"] = (
                    f"Just so you know - {request.urgency_hook}. I'd hate for you to miss out."
                )
        else:
            # Standard handlers for other goals
            handlers = {
                "too_expensive": f"I understand. Let me explain what's included with {request.product} and the value it provides...",
                "need_to_think": "Of course, this is an important decision. What specific aspects would you like to consider?",
                "not_interested": "I appreciate your time. May I ask what would make this more relevant for you?",
                "bad_timing": "I completely understand. When would be a better time to connect?",
            }

        return handlers

    def _generate_closing_script(self, request: CallRequest) -> str:
        """Generate closing script based on goal.

        TODO: Implement with DSPy module.
        """
        if request.goal == CallGoal.CLOSE_SALE:
            return "Perfect! I'll send the payment link to your email right away. You should receive it within a minute. Any questions before I let you go?"
        elif request.goal == CallGoal.BOOK_MEETING and request.booking_link:
            return "Great! I'll email you the booking link so you can schedule at your convenience. You should receive it shortly."
        elif request.goal == CallGoal.QUALIFY_INTEREST:
            return "Thank you for your time today. Based on our conversation, I'll have our team follow up with more information."
        elif request.goal == CallGoal.COLLECT_INFO:
            return "Thank you for sharing that information. We'll follow up shortly."
        return "Thank you for your time today."


def build_context(
    request: CallRequest,
    lead: Lead,
    llm_model: str | None = None,
    firecrawl_api_key: str | None = None,
) -> ContextInstance:
    """Convenience function to build context for a specific lead.

    Args:
        request: The form submission to build context for.
        lead: The specific lead this context is for.
        llm_model: Optional LLM model for DSPy.
        firecrawl_api_key: Optional Firecrawl API key for website scraping.

    Returns:
        A fully-populated ContextInstance ready for the voice agent.
    """
    builder = ContextBuilder(llm_model=llm_model, firecrawl_api_key=firecrawl_api_key)
    return builder.build(request, lead)


def build_contexts_for_submission(
    request: CallRequest,
    llm_model: str | None = None,
    firecrawl_api_key: str | None = None,
) -> list[ContextInstance]:
    """Build ContextInstances for all leads in a submission.

    Args:
        request: The form submission to build context for.
        llm_model: Optional LLM model for DSPy.
        firecrawl_api_key: Optional Firecrawl API key for website scraping.

    Returns:
        A list of ContextInstances, one per lead.
    """
    builder = ContextBuilder(llm_model=llm_model, firecrawl_api_key=firecrawl_api_key)
    return [builder.build(request, lead) for lead in request.leads]
